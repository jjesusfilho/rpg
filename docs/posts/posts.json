[
  {
    "path": "posts/2021-01-03-pivotagem-com-r-e-postgresql/",
    "title": "Pivotagem com R e PostgreSQL",
    "description": "Nesta postagem, eu mostro como converter dataframes e tabelas\nentre os formatos wide e long tanto no R quanto no PostgreSQL,\nalém de permitir realizar essas operações no banco a partir do R.",
    "author": [
      {
        "name": "José de Jesus Filho",
        "url": "https://rpg.consudata.com.br/pivotagem"
      }
    ],
    "date": "2021-01-03",
    "categories": [],
    "contents": "\nPivotagem\nNeste tutorial, mostraremos como pivotar no R e no PostgreSQL. Pivotar, como o próprio nome sugere, significa rotacionar colunas ou linhas, de modo que, valores contidos em linhas, passam a ser colunas e vice-versa. Em ciência de dados, é mais comum falarmos em formatos wide e formato long. Em SQL, é mais comum falarmos em pivoting e unpivoting, respectivamente. A imagem abaixo ilustra o processo de pivotatem:\n\n\n\nEste tutorial cobre as situações mais simples de pivotagem. No dia a dia da cientista de dados ou da DBA, dataframes e tabelas apresentam-se como estruturas um tanto complexas, as quais exigem transformações prévias para não haver perda de dados ou mesmo resultados indesejados.\nPara começar, vamos importar um simples dataframe em formato wide com os ids dos clientes e pagamentos realizados em cada mês no ano. Se você já tem um banco PostgreSQL rodando, aproveite para escrever esse mesmo dataframe no banco. O dataframe encontra-se aqui\n\n\nlibrary(tidyverse)\nlibrary(lubridate)\n\n\n\n\ncliente\njan\nfev\nmar\nabr\nmai\njun\njul\nago\nset\nout\nnov\ndez\n1\n790\n205\n724\n724\n388\n490\n112\n483\n230\n385\n877\n317\n2\n612\n513\n281\n360\n839\n727\n953\n956\n133\n763\n192\n490\n3\n250\n414\n142\n460\n555\n223\n213\n240\n410\n502\n955\n543\n4\n741\n994\n365\n113\n974\n525\n875\n445\n908\n845\n444\n370\n5\n117\n101\n395\n335\n612\n765\n163\n839\n516\n234\n361\n614\n6\n828\n139\n137\n943\n552\n767\n654\n858\n379\n823\n489\n269\n7\n722\n281\n380\n594\n727\n617\n612\n344\n441\n731\n968\n201\n8\n606\n968\n749\n627\n336\n938\n159\n466\n319\n867\n733\n896\n9\n629\n338\n525\n978\n557\n158\n827\n871\n645\n356\n797\n953\n10\n955\n174\n644\n602\n749\n110\n171\n870\n692\n757\n882\n570\n\nPerceba que os dados estão em formato wide. Cada mês ocupa uma coluna.\nMotivação\nPivotagem é ubiqua tanto em ciência de dados quanto em SQL. Nos grupos do Telegram R Brasil e PostgreSQL BR, questões sobre pivotagem são bastante frequentes.\nNo R, há muitos pacotes e funções destinados à conversão de wide para long e vice-versa. No PostgreSQL, conheço apenas uma extensão, tablefunc, voltada à pivoting, ou seja, colocação da tabela na formato wide. Desconheço qualquer extensão ou função oficial para conversão de wide para long. Por outro lado, a comunidade tem oferecido várias soluções para esta operação. Este tutorial é tributário das sugestões oferecidas por Matheus Olivieira no grupo de PostgreSQL do Telegram e desta solução no SO.\nPivotagem consiste numa ferramenta poderosa para solução de problemas concretos com dados e sua compreensão é uma exigência básica para quem quer manusear dados eficientemente. Alguns exemplos que me vieram à mente enquanto escrevia este tutorial são:\nFormato wide é quase sempre mais apropriado para disponibilizar os dados para visualização. É muito mais fácil observar dados de pagamentos de clientes mês a mês, tendo cada cliente numa linha e cada um dos meses numa coluna.\nFormato wide é também a forma natural como os dados são preenchidos num formulário ou mesmo numa planilha.\nFormato long é, por sua vez, muito melhor para proceder a análises e plotar gráficos. Ao colocar todos os meses numa única coluna e seus respectivos valores em outra, mantendo um terceira com o id ou nome do cliente, você só tem de informar que no eixo x vão os meses e no eixo y vão os valores.\nQuando se realiza webscraping, frequentemente ocorre de não sabermos de antemão quais e quantas variáveis virão em cada página. A forma mais segura de realizar webscraping é manter todas a variáveis numa única coluna com seus respectivos valores em outra, para, num segundo momento, caso seja necessário, converter para formato wide. Esta opção é particularmente útil quando estamos realizando webscraping com R e enviando os dataframes já parseados para o PostgreSQL. Se convertermos para o formato wide de pronto, corremos o risco de tentar inserir uma coluna não existente na tabela contida no banco. Em formato long, esse risco não existe.\nPivotagem no R\nDe wide para long\nComo o dataframe importado acima está em formato wide, vamos colocá-lo em formato long. Para tanto, utilizaremos o pacote tidyr, que já está carregado juntamente com os demais pacotes do tidyverse. Como queremos colocar todos os meses numa mesma coluna e seus respectivos valores numa segunda coluna, é suficiente chamar a função pivot_longer, informando que as colunas são o complemento da coluna cliente.\n\n\npivot_longer(pagamentos,!cliente)\n\n\n# A tibble: 120 x 3\n   cliente name  value\n     <int> <chr> <int>\n 1       1 jan     790\n 2       1 fev     205\n 3       1 mar     724\n 4       1 abr     724\n 5       1 mai     388\n 6       1 jun     490\n 7       1 jul     112\n 8       1 ago     483\n 9       1 set     230\n10       1 out     385\n# … with 110 more rows\n\nSe você quiser informar os novos nomes das variáveis, melhor:\n\n\npagamentos_long <- pivot_longer(pagamentos, \n                                !cliente, \n                                names_to = \"mes\", \n                                values_to =\"valor_pago\")\n\n\n\n\n# A tibble: 120 x 3\n   cliente mes   valor_pago\n     <int> <chr>      <int>\n 1       1 jan          790\n 2       1 fev          205\n 3       1 mar          724\n 4       1 abr          724\n 5       1 mai          388\n 6       1 jun          490\n 7       1 jul          112\n 8       1 ago          483\n 9       1 set          230\n10       1 out          385\n# … with 110 more rows\n\nVeja como fica fácil plotar um gráfico deste novo dataframe:\n\n\npagamentos_long %>% \n  mutate(mes = factor(mes, levels = unique(mes))) %>% \n  ggplot(aes(x = mes, y = valor_pago, fill = mes))+\n  geom_bar(stat = \"identity\") +\n  theme_classic()\n\n\n\n\nDe long para wide\nSe quisermos converter pagamentos_long para pagamentos_wide, ou seja, retornar o formato inicial, basta usar a função pivot_wider. Para tanto, você deve informar quais a colunas ids, se não informar, o R irá usar todas as colunas, com exceção da coluna cujos valores se converterão em colunas, especificada no argumento names_from, e da coluna com valores que serão alocados para as respectivas novas colunas, respectivamente, arguemento values_from.\n\n\npagamentos_wide <- pivot_wider(pagamentos_long, \n                               id_cols = cliente, \n                               names_from = mes, \n                               values_from = valor_pago)\n\n\n\n\ncliente\njan\nfev\nmar\nabr\nmai\njun\njul\nago\nset\nout\nnov\ndez\n1\n790\n205\n724\n724\n388\n490\n112\n483\n230\n385\n877\n317\n2\n612\n513\n281\n360\n839\n727\n953\n956\n133\n763\n192\n490\n3\n250\n414\n142\n460\n555\n223\n213\n240\n410\n502\n955\n543\n4\n741\n994\n365\n113\n974\n525\n875\n445\n908\n845\n444\n370\n5\n117\n101\n395\n335\n612\n765\n163\n839\n516\n234\n361\n614\n6\n828\n139\n137\n943\n552\n767\n654\n858\n379\n823\n489\n269\n7\n722\n281\n380\n594\n727\n617\n612\n344\n441\n731\n968\n201\n8\n606\n968\n749\n627\n336\n938\n159\n466\n319\n867\n733\n896\n9\n629\n338\n525\n978\n557\n158\n827\n871\n645\n356\n797\n953\n10\n955\n174\n644\n602\n749\n110\n171\n870\n692\n757\n882\n570\n\nPivotagem no PostgreSQL\nDe wide para long\nA conversão para formato long no PostgreSQL pode ser feita de várias formas. Eu particularmente gosto da solução apresentada à uma questão no StackOverflow, que basicamente converte as linhas em arrays e, em seguida, dá um unnest em cada um desses arrays. Veja abaixo:\n\nSELECT cliente,\n       unnest(array['jan', 'fev', 'mar','abr','mai','jun','jul','ago','set','out','nov','dez']) AS mes,\n       unnest(array[jan, fev, mar,abr,mai,jun,jul,ago,set,out, nov, dez ]) AS valor_pago\nFROM pagamentos\nORDER BY cliente;\nA limitação deste query é que você tem de mencionar todas as variáveis duas vezes. Para facilitar sua vida, eu criei uma função que usa tidyselect\": pg_pivot_longer. Deste modo, é suficiente chamá-la:\npagamento_long <- pg_pivot_longer(conn,\n                                  tbl = \"pagamentos\",\n                                  cols = !cliente, \n                                  names_to = \"mes\", \n                                  values_to = \"valor_pago\")\nOu se quiser criar no próprio banco, sem importar para o R:\npg_pivot_longer(conn, \n               tbl=\"pagamentos\", \n               new_tbl= \"pagamentos_long\",\n               cols = !cliente, \n               names_to = \"mes\", \n               values_to = \"valor_pago\")\nDe long para wide\nPara converter para formato wide, há muitas formas e você pode consultá-las nesse excelente blog post\nNeste tutorial, irei focar naquela que me parece ser a mais simples e popular, que é usar a cláusula FILTER do PostgreSQL. Vejamos como fica:\n\nSELECT cliente,\n       sum(valor_pago) FILTER (WHERE mes = 'jan') as jan,\n       sum(valor_pago) FILTER (WHERE mes = 'fev') as fev,\n       sum(valor_pago) FILTER (WHERE mes = 'mar') as mar,\n       sum(valor_pago) FILTER (WHERE mes = 'abr') as abr,\n       sum(valor_pago) FILTER (WHERE mes = 'mai') as mai,\n       sum(valor_pago) FILTER (WHERE mes = 'jun') as jun,\n       sum(valor_pago) FILTER (WHERE mes = 'jul') as jul,\n       sum(valor_pago) FILTER (WHERE mes = 'ago') as ago,\n       sum(valor_pago) FILTER (WHERE mes = 'set') as set,\n       sum(valor_pago) FILTER (WHERE mes = 'out') as out,\n       sum(valor_pago) FILTER (WHERE mes = 'nov') as nov,\n       sum(valor_pago) FILTER (WHERE mes = 'dez') as dez\nfrom pagamentos_long\ngroup by cliente\norder by cliente;\nComo na transformação para formato longo, aqui você tem de escrever uma linha para cada uma das novas variáveis. Para facilitar sua vida, eu criei uma função chamada pg_pivot_wider, que permite simplesmente informar qual a coluna onde se encontram as variáveis e qual a coluna onde se encontram os valores, além de informar a as colunas com os ids.\npagamentos_wide <- pg_pivot_wider(conn,\n                                tbl = \"pagamentos_long\", \n                                id_cols= \"cliente\", \n                                names_from = \"mes\", \n                                values_from = \"valor_pago\")\nComo acima, se quiser criar uma nova tabela no banco, basta oferecer o novo nome ao argumento new_tbl\npg_pivot_wider(conn,\n               tbl = \"pagamentos_long\",\n               new_tbl = \"pagamentos_wide\", \n               id_cols= \"cliente\",\n               names_from = \"mes\", \n               values_from = \"valor_pago\")\nAs funções pg_pivot_longer e pg_pivot_wider estão em fase experimental. Não se recomenda usá-las em produção.\n\n\n\n",
    "preview": "posts/2021-01-03-pivotagem-com-r-e-postgresql/pivotagem2.png",
    "last_modified": "2021-01-03T12:30:12-03:00",
    "input_file": {}
  },
  {
    "path": "posts/welcome/",
    "title": "Bem-vinda à  Ciência de Dados com R e PostgreSQL",
    "description": "Bem-vindo a este blog sobre Ciência de Dados com R e PostgreSQL. Periodicamente, irei\npostar tutoriais sobre !",
    "author": [
      {
        "name": "José de Jesus Filho",
        "url": "https://rpg.consudata.com.br"
      }
    ],
    "date": "2021-01-03",
    "categories": [],
    "contents": "\n\n\n\n",
    "preview": {},
    "last_modified": "2021-01-03T09:50:45-03:00",
    "input_file": {}
  }
]
