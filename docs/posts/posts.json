[
  {
    "path": "posts/2021-01-03-joins-no-r-e-no-postgresql/",
    "title": "Joins no R e no PostgreSQL",
    "description": "A short description of the post.",
    "author": [
      {
        "name": "José de Jesus Filho",
        "url": "https://rpg.consudata.com.br"
      }
    ],
    "date": "2021-01-03",
    "categories": [],
    "contents": "\nIntrodução\nUm dos propósitos do curso sobre ciência de dados com R e PostgreSQL é mostrar como realizar as mesmas tarefas nas duas linguagens. Um bom exemplo são as junções ou joins, as quais permitem combinar tabelas ou vetores para gerar uma nova tabela. Você pode emparelhá-las verticalmente, horizontalmente ou criar um produto cartesiano.\nNo emparelhamento vertical, exige-se que as colunas tenham o mesmo nome e os tipos sejam os mesmos. No horizontal, exige-se que os tamanhos da colunas ou vetores sejam os mesmos. Desses tipos de combinações, tratamos em outro tutorial.\nNeste tutorial, iremos falar de combinações, ou melhor, junções, que pressupõem a comparação entre valores de colunas conforme especificação pelo usuário. Essas junções criam tabelas novas, as quais não se confundem com as tabelas originais e que não necessariamente preservam todas as colunas e todas as linhas. Por esta razão, é importante ter claro o que se quer ao juntar tabelas para evitar resultados indesejados. A imagem abaixo ilustra uma operação de inner join.\n\n\n\nJunções no R e no PostgreSQL podem ser usadas para diferentes propósitos. No R junções são úteis no processo de transformação dos dados, ou seja, geralmente extraímos dados de diferentes fontes e queremos juntá-los para compor novos dados. Por vezes, a junção é um passo intermediário na programação sem qualquer fim em si mesma.\nJá no PostgreSQL, a junção é geralmente realizada nas buscas de tabelas normalizadas, ou seja, quando as informações a serem passadas para o cliente via query estão dispersas em várias tabelas. Ademais, servem para denormalizar o banco a fim de melhorar o desempenho de queries.\nEm suma, no R junções são especialmente usadas como técnica de programação e manuseio de dados, em SQL como estratégia de armazenamento e extração (queries) de dados.\nAlém disso, como no R a ordem em que aparecem os valores num vetor importa, adicionar uma coluna ao dataframe é uma mera questão de emparelhamento, ou seja, usando df$nova_coluna <- vetor_externo ou tibble::add_column(df,nova_coluna = vetor_externo). Por sua vez, SQL não possui noção de ordem, de modo que o emparelhamento horizontal se faz por meio de joins.\nAntes de realizar joins, tente responder para si mesma questões como:\n1 - Quero preservar todas as linhas das duas tabelas?\n2 - Quero preservar todas as linhas de apenas uma tabela?\n3 - Quero preservar todas as colunas de ambas tabelas?\n4 - Quero preservar NAs (no R) ou NULLs no PostgreSQL?\n5 - Quero juntar as tabelas com base na comparação de apenas um par de colunas, ou seja, coluna a da tbl1 com coluna b da tbl2?\n6 - Se fizer conforme a pergunta 5, o que vai acontecer com colunas com o mesmo nome nas duas tabelas, mas que não pretendo comparar para efeitos de junção?\n7 - Quero valores das duas tabelas ou apenas de uma?\nPacotes necessários\nPara você não ser tomada de surpresa, vamos carregar os pacotes necessários logo no início. Assim, se você não tiver algum deles, trate de instalá-los.\n\n\nlibrary(dplyr)\nlibrary(tibble)\nlibrary(pander)\nlibrary(DBI)\n\n\n\nJoins no R com Tidyverse\nNo R base, existe a função merge. No entanto, eu irei adotar a abordagem tidyverse para os joins. Uma das razões para usar o tidyverse é o fato de ele ser bem documentado.\nUm dos pacotes mais importantes do tidyverse é o dplyr. Ele possui dois grupos de joins. Um grupo de joins de mutação, composto pelos seguintes joins:\n1 - inner_join = mantêm todas as linhas de x e de y;\n2 - left_join = mantêm todas as linhas de x;\n3 - right_join = mantêm todas as linhas de y;\n4 - full_join = mantêm todas as linhas de x e de y.\nO segundo grupo é formado por joins de filtragem. A caractística desses joins é que eles retornam apenas o primeiro dataframe, filtrado com base na comparação com outro dataframe.\n1 - semi_join = retorna todas as linhas x que encontram correpondentes em y;\n2 - anti_join = retorna todas as linhas de x que não encontram correspondentes em y.\nHá uma terceira forma de join chamada self_join, que na verdade é um inner_join de uma tabela com ela mesma.\nVamos iniciar por criar dois dataframes. Mais adiante enviaremos para o PostgreSQL.\n\n\nset.seed(035)\nd1 <- tibble::tibble(a=sample(1:5,5),\n                     b=sample(c(NA_real_,6:9),5),\n                     c=sample(c(NA_character_,sample(letters,4)),5))\npander::pander(d1)\n\n\na\nb\nc\n2\nNA\nj\n5\n6\ni\n1\n9\nNA\n3\n8\nu\n4\n7\nq\n\nPerceba que eu incluí NAs propositalmente para aprendermos como tratar deles tanto no R quanto no PostgreSQL.\n\n\nset.seed(936)\nd2 <- tibble::tibble(a= sample(c(NA_real_,2:7),7),b=sample(c(NA_real_,3:8),7))\npander::pander(d2)\n\n\na\nb\n4\n5\n2\n3\n7\n6\n6\n8\n3\nNA\n5\n7\nNA\n4\n\nOs dois dataframes possuem duas colunas com o mesmo nome a e b, porém o dataframe d1 possui uma coluna a mais, chamada c.\nInner join com Tidyverse\nInner join comparando apenas um par de colunas.\nNo inner_join, o dataframe resultante mantêm todas as linhas dos dois outros dataframes onde os valores das colunas a serem comparadas, que doravante chamaremos chaves, são comuns, descartando as linhas de um que não encontram correspondente no outro.\n\n\nd3 <- inner_join(d1,d2,by = \"a\")\npander(d3)\n\n\na\nb.x\nc\nb.y\n2\nNA\nj\n3\n5\n6\ni\n7\n3\n8\nu\nNA\n4\n7\nq\n5\n\nComo a coluna b está presente nos dois dataframes, mas não foi usada para comparação, o R tratou de renomeá-las para indicar que b.x vem do primeiro dataframe e b.y, do segundo.\nFrequentemente, eu me vejo na situação em que a coluna de um dataframe contêm valores que quero usar para substitir valores ausentes (NAs) em outra coluna do dataframe.\nAo dar o join acima, eu não fiz referência à coluna b presente nos dois dataframes, pois quero preservar o valores originais para, posteriormente, substituir os NAs.\nPara tanto, vem à calhar a função coalesce. Ela serve para substitir os valores ausentes de uma coluna ou de um vetor por valores de outra coluna ou vetor e vice-versa. Vamos substituir os valores ausentes das colunas b.x por seus correspondentes na coluna b.y.\n\n\nd3 <- d3 %>% \n  mutate(b = coalesce(b.x,b.y))\npander(d3)\n\n\na\nb.x\nc\nb.y\nb\n2\nNA\nj\n3\n3\n5\n6\ni\n7\n6\n3\n8\nu\nNA\n8\n4\n7\nq\n5\n7\n\nQuando ambas colunas possuem valores existentes, coalesce preserva os da primeira e descarta os da segunda. Então, se você quiser preservar os da segunda, é só inverter a ordem dos argumentos.\nInner join comparando mais de um par de colunas.\nO procedimento aqui é similiar, porém mais estrito, pois se exige que dois valores numa mesma linha encontrem correspondentes no outro dataframe. No caso, não houve correspondência e o retorno foi um dataframe com zero linhas.\n\n\ninner_join(d1,d2,by=c(\"a\",\"b\")) %>% \n  pander()\n\n\na\nb\nc\n\nNote que, no dataframe d1, na linha em que a coluna a contêm o valor 3, a coluna b contêm o valor 8. Por sua vez, no dataframe d2, na linha em que a coluna a contêm o valor 3, a coluna b é NA. O inner_join ao comparar um valor conhecido com um NA retorna NA e acaba por descartar aquela linha.\nNeste caso, você pode omitir o argumento by e o R irá interpretar que você quer realizar o join com base em todas as colunas do mesmo nome de ambos dataframes. Esse join é chamado de natural join em SQL. No R será emitida uma mensagem indicando quais as colunas foram utilizadas para o join:\n\n\ninner_join(d1,d2) %>% \n  pander()\n\n\nJoining, by = c(\"a\", \"b\")\na\nb\nc\n\nPara evitar surpresas, é recomendável adotar a primeira abordagem, qual seja, explicitar as chaves.\nInner joins com nomes diferentes de chaves.\nAgora suponha que você queira dar um join por duas colunas com nomes diferentes, a família join do dplyr possui uma uma sintaxe bem particular. Eu vou criar um novo dataframe a partir do d1 e renomear a coluna a para aa, para então compará-la com a coluna a do dataframe b.\n\n\nd4 <- d1 %>% \n  select(aa = a, everything())\npander(d4)\n\n\naa\nb\nc\n2\nNA\nj\n5\n6\ni\n1\n9\nNA\n3\n8\nu\n4\n7\nq\n\n\n\nd5 <- inner_join(d4,d2,by=c(\"aa\"=\"a\"))\npander(d5)\n\n\naa\nb.x\nc\nb.y\n2\nNA\nj\n3\n5\n6\ni\n7\n3\n8\nu\nNA\n4\n7\nq\n5\n\nComo você pode observar, o nome preservado é o do dataframe da esquerda.\nLeft join e right join\nAs funções left_join e right_join são similares. A primeira preserva todas a linhas do dataframe à da esquerda, a segunda, da direita.\n\n\nd6 <- left_join(d1,d2, by = \"a\")\npander(d6)\n\n\na\nb.x\nc\nb.y\n2\nNA\nj\n3\n5\n6\ni\n7\n1\n9\nNA\nNA\n3\n8\nu\nNA\n4\n7\nq\n5\n\n\n\nd7 <- right_join(d1,d2, by=\"a\")\npander(d7)\n\n\na\nb.x\nc\nb.y\n2\nNA\nj\n3\n5\n6\ni\n7\n3\n8\nu\nNA\n4\n7\nq\n5\n7\nNA\nNA\n6\n6\nNA\nNA\n8\nNA\nNA\nNA\n4\n\nÉ importante notar que, tanto no left join e right join quanto no full join, o R realiza um coalesce entre as chaves. Se você quiser preservar as colunas originais, adicione o argumento keep = TRUE:\n\n\nd8 <- left_join(d1,d2,by = \"a\",keep = TRUE)\npander(d8)\n\n\na.x\nb.x\nc\na.y\nb.y\n2\nNA\nj\n2\n3\n5\n6\ni\n5\n7\n1\n9\nNA\nNA\nNA\n3\n8\nu\n3\nNA\n4\n7\nq\n4\n5\n\nFull join\nDiferentemente dos anteriores, full join preserva todas as linhas de ambos dataframes, encontrando ou não valores correspondentes.\n\n\nd9 <- full_join(d1,d2, by = \"a\")\npander(d9)\n\n\na\nb.x\nc\nb.y\n2\nNA\nj\n3\n5\n6\ni\n7\n1\n9\nNA\nNA\n3\n8\nu\nNA\n4\n7\nq\n5\n7\nNA\nNA\n6\n6\nNA\nNA\n8\nNA\nNA\nNA\n4\n\n\n\nd10 <- full_join(d1,d2, by=c(\"a\",\"b\"))\npander(d10)\n\n\na\nb\nc\n2\nNA\nj\n5\n6\ni\n1\n9\nNA\n3\n8\nu\n4\n7\nq\n4\n5\nNA\n2\n3\nNA\n7\n6\nNA\n6\n8\nNA\n3\nNA\nNA\n5\n7\nNA\nNA\n4\nNA\n\nJoins de filtragem\nJoins de filtragem servem para filtrar as linhas de um dataframe com base em seus correspondentes no outro dataframe. Eles não retornam nada do segundo dataframe, apenas do primeiro.\nFunção semi_join\n\n\nd11 <- semi_join(d1,d2,by = \"a\")\npander(d11)\n\n\na\nb\nc\n2\nNA\nj\n5\n6\ni\n3\n8\nu\n4\n7\nq\n\nVeja que as colunas de d2 foram dispensadas. Semi join é similar à seguinte operação:\n\n\nd12 <- d1 %>% \n      filter(a %in% d2$a)\npander(d12)\n\n\na\nb\nc\n2\nNA\nj\n5\n6\ni\n3\n8\nu\n4\n7\nq\n\nAnti join\nAnti join, como o próprio nome indica, retorna apenas as linhas de um dataframe cuja chave não encontra correspondente no segundo dataframe.\n\n\nd13 <- anti_join(d1,d2, by = \"a\")\n\npander(d13)\n\n\na\nb\nc\n1\n9\nNA\n\nAnti join é equivalente a:\n\n\nd14 <- d1 %>% \n      filter(!a %in% d2$a)\npander(d14)\n\n\na\nb\nc\n1\n9\nNA\n\nJoins no PostgreSQL\nINNER JOIN\nInner join no PostgreSQL é muito similar ao inner join no R, com a diferença de que, se houver colunas com mesmo nome que não forem usadas para comparação, elas são mantidas com o mesmo nome, o que pode gerar confusão.\nQuanto à sintaxe, ela é bem intuitiva. Se quiser juntar todas as colunas tanto de uma tabela, quanto da outra, basta colocar um asterisco depois do SELECT, indicar a primeira tabela com FROM, chamar o INNER JOIN e indicar a segunda tabela. Para indicar uma ou mais chaves, coloque-as entre parênteses depois de USING.\nINNER JOIN com uma chave\nSELECT * FROM d1 INNER JOIN d2 USING (a);\na\nb\nc\nb\n2\n\nj\n3\n3\n8\nu\n\n4\n7\nq\n5\n5\n6\ni\n7\nINNER JOIN com mais de uma chave\nSELECT * FROM d1 INNER JOIN d2 USING (a,b);\na\nb\nc\n(0 rows)\nPara obter o resultado com colunas diferentes, você pode juntar a primeira tabela com um subquery da segunda, pelo qual você alterou os nomes apropriadamente.\nSELECT * FROM d1 INNER JOIN (SELECT a, b AS b_y FROM d2) AS foo  USING (a);\na\nb\nc\nb_y\n2\n\nj\n3\n3\n8\nu\n\n4\n7\nq\n5\n5\n6\ni\n7\n(4 rows)\nNATURAL JOIN\nAssim como no R, se você omitir o by, o join acontecerá com todas as colunas com o mesmo nome. No PostgreSQL, você obtêm o mesmo resultado informando que se trata de um natural join:\nSELECT * FROM d1 NATURAL INNER JOIN d2;\na\nb\nc\n(0 rows)\nOUTER JOINS\nSob o nome genérico de OUTER JOIN, encontram-se LEFT E RIGHT e FULL joins. A palavra OUTER pode ser omitida no query.\nBasicamente o que ele faz é realizar um INNER JOIN no primeiro momento e, em seguida, um novo JOIN é realizado para conter os valores da tabela de referência e NULL da tabela seguinte.\n\nSELECT * FROM  d1 LEFT OUTER JOIN d2 USING (a);\na\nb\nc\nb\n1\n9\n\n\n2\n\nj\n3\n3\n8\nu\n\n4\n7\nq\n5\n5\n6\ni\n7\n(5 rows)\nA cláusula USING não é mais que um atalho para d1.a = d2.a:\nSELECT * FROM  d1 LEFT OUTER JOIN d2 on d1.a = d2.a;\nOu\nSELECT * FROM  d1 LEFT OUTER JOIN d2 ON d1.a = d2.a AND d1.b = d2.b;\nIgualmente, se você quiser realizar um NATURAL JOIN:\n\nselect * from d1 natural left outer join d2;\na\nb\nc\n1\n9\n\n2\n\nj\n3\n8\nu\n4\n7\nq\n5\n6\ni\n(5 rows)\nVocê pode também usar a cláusula WHERE para filtrar depois do join:\nSELECT * FROM d1 LEFT JOIN d2 ON t1.a = t2.a WHERE t2.b = 3;\na\nb\nc\na\nb\n2\n\nj\n2\n3\n(1 row)\nFULL JOIN segue o mesmo padrão anterior:\n\nSELECT * FROM  d1 FULL OUTER JOIN d2 USING (a);\na\nb\nc\nb\n1\n9\n\n\n2\n\nj\n3\n3\n8\nu\n\n4\n7\nq\n5\n5\n6\ni\n7\n6\n\n\n8\n7\n\n\n6\n\n\n4\n\n(8 rows)\nMuito mais pode ser feito com joins tanto no R quanto no PostgreSQL, mas este já é um bom começo.\nAnti Join no PostgreSQL\nO PostgreSQL permite quatro formas de anti joins. Vamos mostrar cada uma delas. Eu usei este post como referência.\nNOT EXISTS\nRápida, segura e eficiente, prefira esta sempre que possível.\nSELECT * FROM d1 \nWHERE NOT EXISTS(\nSELECT  -- Não precisa selecionar coluna alguma.\nFROM d2\nWHERE a = d1.a);\na\nb\nc\n1\n9\n\n(1 row)\nLEFT JOIN com IS NULL\nEsta forma é tão rápida quanto, mas não tão eficiente, pois pode retornar colunas extras.\nSELECT * FROM d1\nLEFT JOIN d2 using(a)\nWHERE d2.a is NULL;\na\nb\nc\nb\n1\n9\n\n\n(1 row)\nEXCEPT ALL\nSe para você basta retornar a coluna de comparação, use execpt all:\nSELECT a\nFROM d1\nEXCEPT ALL\nSELECT a\nFROM d2;\na\n1 (1 row)\nNOT IN\nParticularmente, acho mais intuitiva, mas é mais arriscada, pois pode retornar resultados indesejados se houver NULL em um dos lados. Vejamos um exemplo em o resultado é inexperado.\nSELECT * \nFROM d1\nWHERE a NOT IN (\nSELECT a \nFROM d2);\na\nb\nc\n(0 rows)\nIsto aconteceu porque há nulos na coluna a da tabela d2. Para não correr este risco, assegure-se de ajustar para não nulos na referida coluna:\n\nSELECT *\nFROM d1\nWHERE a NOT IN (\nSELECT a\nFROM d2\nWHERE a IS NOT NULL);\na\nb\nc\n1\n9\n\n(1 row)\nSELF JOIN\nSelf joins são nada mais que joins de uma tabela com ela mesma. Este join é particularmente útil quando temos valores comuns entre duas colunas distintas. Uma situação típica é a de quando temos numa coluna o id de funcionários e na outra se seus respectivos supervisores, sendo esses também funcionários. Vejamos um exemplo.\n\n\nfunc <- tibble::tibble(\n  \n  id_funcionario = c(1:8),\n  nome = c(\"Heloísa\",\"Daniel\",\"Thandara\",\"Naiara\",\"Patrick\",\"Haydee\",\"Julia\",\"Fabio\"),\n  id_supervisor = c(NA_real_,1,1,2,2,3,3,3)\n)\npander(func)\n\n\nid_funcionario\nnome\nid_supervisor\n1\nHeloísa\nNA\n2\nDaniel\n1\n3\nThandara\n1\n4\nNaiara\n2\n5\nPatrick\n2\n6\nHaydee\n3\n7\nJulia\n3\n8\nFabio\n3\n\nSelf join no R\nSelf join no R não é mais que um inner join combinando uma coluna, id do suprvisor, da primeira tabela com outra coluna, id do funcionário, da segunda tabela. Aproveitamos para selecionar as colunas de interesse e nomeá-las adequadamento.\n\n\ndplyr::inner_join(func,func,by = c(\"id_supervisor\"= \"id_funcionario\")) %>%\n  dplyr::select(funcionario = nome.x, supervisor = nome.y) %>% \n  pander()\n\n\nfuncionario\nsupervisor\nDaniel\nHeloísa\nThandara\nHeloísa\nNaiara\nDaniel\nPatrick\nDaniel\nHaydee\nThandara\nJulia\nThandara\nFabio\nThandara\n\nSelf join no PostgreSQL\nSelf join no PostgreSQL se dá da mesma forma. A diferença é que a sintaxe muda um pouquinho, mas o resultado é exatamente o mesmo.\n\nSELECT f.nome funcionario, s.nome supervisor\n       FROM func f \n       JOIN func s ON s.id_funcionario = f.id_supervisor; \n\n\nfuncionario\nsupervisor\nDaniel\nHeloísa\nThandara\nHeloísa\nNaiara\nDaniel\nPatrick\nDaniel\nHaydee\nThandara\nJulia\nThandara\nFabio\nThandara\n\nConsiderações finais\nJoins no R são mais fáceis, mas têm suas limitações de desempenho. Por sua vez, no PostgreSQL o ganho de desempenho é extraordinário quando o banco está normalizado, com criação de índices e restrições, especificamente chaves primárias e estrangeiras. Esses dois recursos, quando usados apropriadamente, reduzem significativamente o tempo de resposta. Sem contar outros benefícios, como alta disponibilidade, nível de organização e segurança dos dados.\n\n\n\n",
    "preview": "posts/2021-01-03-joins-no-r-e-no-postgresql/inner_join.png",
    "last_modified": "2021-01-03T13:46:00-03:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-01-03-pivotagem-com-r-e-postgresql/",
    "title": "Pivotagem com R e PostgreSQL",
    "description": "Nesta postagem, eu mostro como converter dataframes e tabelas\nentre os formatos wide e long tanto no R quanto no PostgreSQL,\nalém de permitir realizar essas operações no banco a partir do R.",
    "author": [
      {
        "name": "José de Jesus Filho",
        "url": "https://rpg.consudata.com.br/pivotagem"
      }
    ],
    "date": "2021-01-03",
    "categories": [],
    "contents": "\nPivotagem\nNeste tutorial, mostraremos como pivotar no R e no PostgreSQL. Pivotar, como o próprio nome sugere, significa rotacionar colunas ou linhas, de modo que, valores contidos em linhas, passam a ser colunas e vice-versa. Em ciência de dados, é mais comum falarmos em formatos wide e formato long. Em SQL, é mais comum falarmos em pivoting e unpivoting, respectivamente. A imagem abaixo ilustra o processo de pivotatem:\n\n\n\nEste tutorial cobre as situações mais simples de pivotagem. No dia a dia da cientista de dados ou da DBA, dataframes e tabelas apresentam-se como estruturas um tanto complexas, as quais exigem transformações prévias para não haver perda de dados ou mesmo resultados indesejados.\nPara começar, vamos importar um simples dataframe em formato wide com os ids dos clientes e pagamentos realizados em cada mês no ano. Se você já tem um banco PostgreSQL rodando, aproveite para escrever esse mesmo dataframe no banco. O dataframe encontra-se aqui\n\n\nlibrary(tidyverse)\nlibrary(lubridate)\n\n\n\n\ncliente\njan\nfev\nmar\nabr\nmai\njun\njul\nago\nset\nout\nnov\ndez\n1\n790\n205\n724\n724\n388\n490\n112\n483\n230\n385\n877\n317\n2\n612\n513\n281\n360\n839\n727\n953\n956\n133\n763\n192\n490\n3\n250\n414\n142\n460\n555\n223\n213\n240\n410\n502\n955\n543\n4\n741\n994\n365\n113\n974\n525\n875\n445\n908\n845\n444\n370\n5\n117\n101\n395\n335\n612\n765\n163\n839\n516\n234\n361\n614\n6\n828\n139\n137\n943\n552\n767\n654\n858\n379\n823\n489\n269\n7\n722\n281\n380\n594\n727\n617\n612\n344\n441\n731\n968\n201\n8\n606\n968\n749\n627\n336\n938\n159\n466\n319\n867\n733\n896\n9\n629\n338\n525\n978\n557\n158\n827\n871\n645\n356\n797\n953\n10\n955\n174\n644\n602\n749\n110\n171\n870\n692\n757\n882\n570\n\nPerceba que os dados estão em formato wide. Cada mês ocupa uma coluna.\nMotivação\nPivotagem é ubiqua tanto em ciência de dados quanto em SQL. Nos grupos do Telegram R Brasil e PostgreSQL BR, questões sobre pivotagem são bastante frequentes.\nNo R, há muitos pacotes e funções destinados à conversão de wide para long e vice-versa. No PostgreSQL, conheço apenas uma extensão, tablefunc, voltada à pivoting, ou seja, colocação da tabela na formato wide. Desconheço qualquer extensão ou função oficial para conversão de wide para long. Por outro lado, a comunidade tem oferecido várias soluções para esta operação. Este tutorial é tributário das sugestões oferecidas por Matheus Olivieira no grupo de PostgreSQL do Telegram e desta solução no SO.\nPivotagem consiste numa ferramenta poderosa para solução de problemas concretos com dados e sua compreensão é uma exigência básica para quem quer manusear dados eficientemente. Alguns exemplos que me vieram à mente enquanto escrevia este tutorial são:\nFormato wide é quase sempre mais apropriado para disponibilizar os dados para visualização. É muito mais fácil observar dados de pagamentos de clientes mês a mês, tendo cada cliente numa linha e cada um dos meses numa coluna.\nFormato wide é também a forma natural como os dados são preenchidos num formulário ou mesmo numa planilha.\nFormato long é, por sua vez, muito melhor para proceder a análises e plotar gráficos. Ao colocar todos os meses numa única coluna e seus respectivos valores em outra, mantendo um terceira com o id ou nome do cliente, você só tem de informar que no eixo x vão os meses e no eixo y vão os valores.\nQuando se realiza webscraping, frequentemente ocorre de não sabermos de antemão quais e quantas variáveis virão em cada página. A forma mais segura de realizar webscraping é manter todas a variáveis numa única coluna com seus respectivos valores em outra, para, num segundo momento, caso seja necessário, converter para formato wide. Esta opção é particularmente útil quando estamos realizando webscraping com R e enviando os dataframes já parseados para o PostgreSQL. Se convertermos para o formato wide de pronto, corremos o risco de tentar inserir uma coluna não existente na tabela contida no banco. Em formato long, esse risco não existe.\nPivotagem no R\nDe wide para long\nComo o dataframe importado acima está em formato wide, vamos colocá-lo em formato long. Para tanto, utilizaremos o pacote tidyr, que já está carregado juntamente com os demais pacotes do tidyverse. Como queremos colocar todos os meses numa mesma coluna e seus respectivos valores numa segunda coluna, é suficiente chamar a função pivot_longer, informando que as colunas são o complemento da coluna cliente.\n\n\npivot_longer(pagamentos,!cliente)\n\n\n# A tibble: 120 x 3\n   cliente name  value\n     <int> <chr> <int>\n 1       1 jan     790\n 2       1 fev     205\n 3       1 mar     724\n 4       1 abr     724\n 5       1 mai     388\n 6       1 jun     490\n 7       1 jul     112\n 8       1 ago     483\n 9       1 set     230\n10       1 out     385\n# … with 110 more rows\n\nSe você quiser informar os novos nomes das variáveis, melhor:\n\n\npagamentos_long <- pivot_longer(pagamentos, \n                                !cliente, \n                                names_to = \"mes\", \n                                values_to =\"valor_pago\")\n\n\n\n\n# A tibble: 120 x 3\n   cliente mes   valor_pago\n     <int> <chr>      <int>\n 1       1 jan          790\n 2       1 fev          205\n 3       1 mar          724\n 4       1 abr          724\n 5       1 mai          388\n 6       1 jun          490\n 7       1 jul          112\n 8       1 ago          483\n 9       1 set          230\n10       1 out          385\n# … with 110 more rows\n\nVeja como fica fácil plotar um gráfico deste novo dataframe:\n\n\npagamentos_long %>% \n  mutate(mes = factor(mes, levels = unique(mes))) %>% \n  ggplot(aes(x = mes, y = valor_pago, fill = mes))+\n  geom_bar(stat = \"identity\") +\n  theme_classic()\n\n\n\n\nDe long para wide\nSe quisermos converter pagamentos_long para pagamentos_wide, ou seja, retornar o formato inicial, basta usar a função pivot_wider. Para tanto, você deve informar quais a colunas ids, se não informar, o R irá usar todas as colunas, com exceção da coluna cujos valores se converterão em colunas, especificada no argumento names_from, e da coluna com valores que serão alocados para as respectivas novas colunas, respectivamente, arguemento values_from.\n\n\npagamentos_wide <- pivot_wider(pagamentos_long, \n                               id_cols = cliente, \n                               names_from = mes, \n                               values_from = valor_pago)\n\n\n\n\ncliente\njan\nfev\nmar\nabr\nmai\njun\njul\nago\nset\nout\nnov\ndez\n1\n790\n205\n724\n724\n388\n490\n112\n483\n230\n385\n877\n317\n2\n612\n513\n281\n360\n839\n727\n953\n956\n133\n763\n192\n490\n3\n250\n414\n142\n460\n555\n223\n213\n240\n410\n502\n955\n543\n4\n741\n994\n365\n113\n974\n525\n875\n445\n908\n845\n444\n370\n5\n117\n101\n395\n335\n612\n765\n163\n839\n516\n234\n361\n614\n6\n828\n139\n137\n943\n552\n767\n654\n858\n379\n823\n489\n269\n7\n722\n281\n380\n594\n727\n617\n612\n344\n441\n731\n968\n201\n8\n606\n968\n749\n627\n336\n938\n159\n466\n319\n867\n733\n896\n9\n629\n338\n525\n978\n557\n158\n827\n871\n645\n356\n797\n953\n10\n955\n174\n644\n602\n749\n110\n171\n870\n692\n757\n882\n570\n\nPivotagem no PostgreSQL\nDe wide para long\nA conversão para formato long no PostgreSQL pode ser feita de várias formas. Eu particularmente gosto da solução apresentada à uma questão no StackOverflow, que basicamente converte as linhas em arrays e, em seguida, dá um unnest em cada um desses arrays. Veja abaixo:\n\nSELECT cliente,\n       unnest(array['jan', 'fev', 'mar','abr','mai','jun','jul','ago','set','out','nov','dez']) AS mes,\n       unnest(array[jan, fev, mar,abr,mai,jun,jul,ago,set,out, nov, dez ]) AS valor_pago\nFROM pagamentos\nORDER BY cliente;\nA limitação deste query é que você tem de mencionar todas as variáveis duas vezes. Para facilitar sua vida, eu criei uma função que usa tidyselect\": pg_pivot_longer. Deste modo, é suficiente chamá-la:\npagamento_long <- pg_pivot_longer(conn,\n                                  tbl = \"pagamentos\",\n                                  cols = !cliente, \n                                  names_to = \"mes\", \n                                  values_to = \"valor_pago\")\nOu se quiser criar no próprio banco, sem importar para o R:\npg_pivot_longer(conn, \n               tbl=\"pagamentos\", \n               new_tbl= \"pagamentos_long\",\n               cols = !cliente, \n               names_to = \"mes\", \n               values_to = \"valor_pago\")\nDe long para wide\nPara converter para formato wide, há muitas formas e você pode consultá-las nesse excelente blog post\nNeste tutorial, irei focar naquela que me parece ser a mais simples e popular, que é usar a cláusula FILTER do PostgreSQL. Vejamos como fica:\n\nSELECT cliente,\n       sum(valor_pago) FILTER (WHERE mes = 'jan') as jan,\n       sum(valor_pago) FILTER (WHERE mes = 'fev') as fev,\n       sum(valor_pago) FILTER (WHERE mes = 'mar') as mar,\n       sum(valor_pago) FILTER (WHERE mes = 'abr') as abr,\n       sum(valor_pago) FILTER (WHERE mes = 'mai') as mai,\n       sum(valor_pago) FILTER (WHERE mes = 'jun') as jun,\n       sum(valor_pago) FILTER (WHERE mes = 'jul') as jul,\n       sum(valor_pago) FILTER (WHERE mes = 'ago') as ago,\n       sum(valor_pago) FILTER (WHERE mes = 'set') as set,\n       sum(valor_pago) FILTER (WHERE mes = 'out') as out,\n       sum(valor_pago) FILTER (WHERE mes = 'nov') as nov,\n       sum(valor_pago) FILTER (WHERE mes = 'dez') as dez\nfrom pagamentos_long\ngroup by cliente\norder by cliente;\nComo na transformação para formato longo, aqui você tem de escrever uma linha para cada uma das novas variáveis. Para facilitar sua vida, eu criei uma função chamada pg_pivot_wider, que permite simplesmente informar qual a coluna onde se encontram as variáveis e qual a coluna onde se encontram os valores, além de informar a as colunas com os ids.\npagamentos_wide <- pg_pivot_wider(conn,\n                                tbl = \"pagamentos_long\", \n                                id_cols= \"cliente\", \n                                names_from = \"mes\", \n                                values_from = \"valor_pago\")\nComo acima, se quiser criar uma nova tabela no banco, basta oferecer o novo nome ao argumento new_tbl\npg_pivot_wider(conn,\n               tbl = \"pagamentos_long\",\n               new_tbl = \"pagamentos_wide\", \n               id_cols= \"cliente\",\n               names_from = \"mes\", \n               values_from = \"valor_pago\")\nAs funções pg_pivot_longer e pg_pivot_wider estão em fase experimental. Não se recomenda usá-las em produção.\n\n\n\n",
    "preview": "posts/2021-01-03-pivotagem-com-r-e-postgresql/pivotagem2.png",
    "last_modified": "2021-01-03T12:30:12-03:00",
    "input_file": {}
  },
  {
    "path": "posts/welcome/",
    "title": "Bem-vinda à  Ciência de Dados com R e PostgreSQL",
    "description": "Bem-vindo a este blog sobre Ciência de Dados com R e PostgreSQL. Periodicamente, irei\npostar tutoriais sobre !",
    "author": [
      {
        "name": "José de Jesus Filho",
        "url": "https://rpg.consudata.com.br"
      }
    ],
    "date": "2021-01-03",
    "categories": [],
    "contents": "\n\n\n\n",
    "preview": {},
    "last_modified": "2021-01-03T09:50:45-03:00",
    "input_file": {}
  }
]
